# 多线程

## 线程与队列区别
1. 程序分为主线程与子线程, 主线程主要用来更新队列,而主线程所有要处理的事务都放在主队列,主队列是一个串行队列.
2. 线程相当于处理事务的机器,而队列相当于流水线,任务都是放入队列中.

### Pthread:
- 一套通用的多线程API.
- 纯C语言跨平台.
- 程序员管理线程生命.

### NSThread:
- 使用更加面向对象,能够操作单独线程对象.
- 程序员管理线程生命

### GCD相关: (常用)
- 自动管理线程生命.
- 性能优于NSThread.
1. `dispathc_async`与`dispatch_sync`区别:
	- async有开启新线程能力,如果是并发队列就能开启多线程并发任务,如果是串行队列,就只开启一个子线程.
	- async不会卡住当前线程,会将任务入队,然后执行后续任务. 
	- sync没有开启线程能力,按照给定队列来确定线程.
	- sync会卡住当前线程,执行完当前任务才会将后续任务入队列.
	
	| | 并发队列 | 串行队列(自己创建) | 主队列(串行) | 
	|:-|:	-    |: 		-         |: 	-        |
	|sync|不会开启新线程,串行执行任务| 不会开启线程,串行执行任务| 不会开启线程,串行执行任务|
	|async|开启新线程,并发执行任务|开启新线程,串行执行任务|不会开启新线程,串行执行任务|
	
	|123|234|345|
	|:-|:-:|-:|
	|abc|bcd|cde|
	|abc|bcd|cde|
	|abc|bcd|cde|	

	> 使用sync往当前串行队列添加任务,会卡死.

2. 使用GCD完成任务依赖.
	1. 创建Group.`dispatch_group_create()`
	2. 创建队列.
	3. 将先执行任务加入队列,并传入group.`dispatch_group_async`
	4. gropu执行完了调用`dispatch_group_notify`放入后面要执行任务.

### NSOperation: (常用)
- 基于GCD,比GCD多了一些方法.
- 更加面向对象.

1. 添加任务依赖关系
2. 添加任务等待关系,阻塞等待任务完成再执行.
3. 对个队列添加任务依赖关系.
4. 设置任务的优先级
> 使用过程,创建NSOperationQueue -> 创建NSBlockOperation -> 将任务加入队列

##### 线程安全问题
1. `OSSpinLock` : 自旋锁,效率高,占用CPU,废弃了,会产生优先级反转,导致优先级较高的线程时间更多,而被锁线程时间更少.
2. `os_unfair_lock` : 互斥锁
3. `pthread_mutex` : 互斥锁,跨平台,基于C实现.
4. `dispatch_semaphore` : 信号量, 信号量数值觉得最多能进入的线程树,一般设置为1. 
5. `NSLock` : 互斥锁,对pthread普通锁的封装
6. `NSRecursiveLock` : 递归锁,也是互斥锁, 解决递归调用死锁问题.对pthread递归锁的封装.
7. `NSCondition` : 对pthread条件与锁的封装.
8. `NSConditionLock` :  对NSCondition的进一步封装,可以设置具体的条件.
9. `@synchorized` : 同步,可以对代码块使用.
> 使用同步串行队列也能保证线程安全.因为同一时间,没有线程修改同一个资源.
- 多读单写实现: `dispatch_barrier_async` , `读写锁`



